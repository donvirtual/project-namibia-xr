<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibeke's Grote Expeditie - ROBUUST</title>

    <!-- A-Frame Core -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>

    <!-- A-Frame Extras (Animation Support) -->
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.2.0/dist/aframe-extras.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; overflow: hidden; }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 100;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #FFD700;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.9);
        }

        .level-title { font-size: 2rem; font-weight: bold; margin-bottom: 0.5rem; }
        .objective { font-size: 1.2rem; color: #FFF; }
        .progress { font-size: 1.5rem; color: #FF6347; margin-top: 0.5rem; }

        #skip-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 0.8rem 1.5rem;
            background: rgba(255,99,71,0.8);
            color: #FFF;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            z-index: 200;
            pointer-events: all;
        }

        #debug-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            z-index: 200;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <div id="hud">
            <div class="level-title" id="level-title">üåç VIBEKE'S EXPEDITIE</div>
            <div class="objective" id="objective">Laden...</div>
            <div class="progress" id="progress"></div>
        </div>
    </div>

    <button id="skip-btn" onclick="window.gameManager && window.gameManager.skipLevel()">‚è≠Ô∏è SKIP</button>

    <div id="debug-panel">
        <div id="debug-hands">Handen: Wachten op VR...</div>
        <div id="debug-level">Level: -</div>
    </div>

    <a-scene
        webxr="referenceSpaceType: local-floor; optionalFeatures: hand-tracking"
        cursor="rayOrigin: mouse"
        renderer="colorManagement: true; physicallyCorrectLights: true; antialias: true"
        loading-screen="dotsColor: #FFD700; backgroundColor: #1a1a1a"
        vr-mode-ui="enabled: true">

        <!-- ASSETS -->
        <a-assets timeout="15000">
            <a-asset-item id="rhino-asset" src="assets/rhino.glb"></a-asset-item>
            <a-asset-item id="hunter-asset" src="assets/hunter.glb"></a-asset-item>
            <a-asset-item id="fly-model" src="assets/Fly.glb"></a-asset-item>
            <a-asset-item id="heart-model" src="assets/bottle.glb"></a-asset-item>
            <a-asset-item id="deer-asset" src="assets/deer.gltf"></a-asset-item>
            <a-asset-item id="stag-asset" src="assets/stag.gltf"></a-asset-item>
            <a-asset-item id="bull-asset" src="assets/bull.gltf"></a-asset-item>
            <a-asset-item id="horse-asset" src="assets/horse.gltf"></a-asset-item>
            <a-asset-item id="fox-asset" src="assets/fox.gltf"></a-asset-item>
            <a-asset-item id="giraffe-asset" src="assets/giraffe.glb"></a-asset-item>
            <a-asset-item id="tree-asset" src="assets/Acacia.glb"></a-asset-item>

            <img id="sky-asset" src="assets/pexels-francesco-ungaro-998641.jpg" crossorigin="anonymous">
            <img id="ground-asset" src="assets/Ground096B_1K-JPG/Ground096B_1K-JPG_Color.jpg" crossorigin="anonymous">

            <audio id="wind-loop" src="assets/desert-wind-1-350398.mp3" preload="auto"></audio>
            <audio id="insects-loop" src="assets/desert-insects-52089.mp3" preload="auto"></audio>
            <audio id="fart-sound" src="assets/wet-fart-6139.mp3" preload="auto"></audio>
            <audio id="squishy-loop" src="assets/wet-squishy-sound-34303.mp3" preload="auto" loop></audio>
        </a-assets>

        <!-- ENVIRONMENT -->
        <a-sky src="#sky-asset" rotation="0 -90 0"
            animation="property: rotation; to: 0 270 0; dur: 240000; easing: linear; loop: true">
        </a-sky>

        <!-- Wavy terrain generated by component -->
        <a-entity id="terrain" wavy-terrain></a-entity>

        <!-- LIGHTING -->
        <a-entity light="type: directional; color: #AADDEE; intensity: 0.8" position="-20 25 10"></a-entity>
        <a-entity light="type: ambient; color: #443333; intensity: 0.6"></a-entity>
        <a-entity light="type: point; color: #FFaa00; intensity: 1.2; distance: 5" position="2 1 -1"></a-entity>

        <!-- CAMERA RIG -->
        <a-entity id="rig" position="0 0 0">
            <a-camera id="camera" position="0 1.6 5" look-controls wasd-controls="acceleration: 20">
                <!-- Gaze cursor for Level 1 ONLY -->
                <a-cursor id="gaze-cursor" color="#FFD700" opacity="0.8"
                    raycaster="objects: .clickable; far: 150"
                    fuse="true" fuse-timeout="1000">
                </a-cursor>
            </a-camera>

            <!-- HAND VISUAL INDICATORS (DEBUG) -->
            <a-sphere id="left-hand-indicator" radius="0.08" color="#FF0000" opacity="0.7" visible="false"></a-sphere>
            <a-sphere id="right-hand-indicator" radius="0.08" color="#00FF00" opacity="0.7" visible="false"></a-sphere>

            <!-- SHIELD (for Level 3) -->
            <a-entity id="shield" visible="false" position="0 1.4 -0.5"
                geometry="primitive: cylinder; radius: 0.5; height: 0.05"
                material="color: #4169E1; metalness: 0.8; emissive: #1E90FF; emissiveIntensity: 0.5; opacity: 0.9; transparent: true"
                rotation="90 0 0">
            </a-entity>
        </a-entity>

        <!-- GAME MANAGER -->
        <a-entity id="game-manager" robust-game-manager></a-entity>

    </a-scene>

    <script>
        console.log('üéÆ ROBUUSTE GAME VERSIE - LOADING...');

        // =====================================================
        // ANIMAL WALKER COMPONENT - Makes animals walk and face correct direction
        // =====================================================
        AFRAME.registerComponent('animal-walker', {
            schema: {
                startX: { type: 'number', default: 0 },
                startZ: { type: 'number', default: 0 },
                endX: { type: 'number', default: 5 },
                endZ: { type: 'number', default: 5 },
                duration: { type: 'number', default: 20000 }
            },

            init: function() {
                this.progress = 0;
                this.direction = 1; // 1 = forward, -1 = backward
                this.hasSetRotation = false;
            },

            tick: function(time, delta) {
                if (!delta) return;

                const d = this.data;

                // Update progress
                this.progress += (delta / d.duration) * this.direction;

                // Reverse at ends
                if (this.progress >= 1) {
                    this.progress = 1;
                    this.direction = -1;
                } else if (this.progress <= 0) {
                    this.progress = 0;
                    this.direction = 1;
                }

                // Calculate position
                const x = d.startX + (d.endX - d.startX) * this.progress;
                const z = d.startZ + (d.endZ - d.startZ) * this.progress;
                this.el.object3D.position.set(x, 0, z);

                // Face movement direction (models typically face -Z, so we rotate 180)
                const dx = this.direction > 0 ? (d.endX - d.startX) : (d.startX - d.endX);
                const dz = this.direction > 0 ? (d.endZ - d.startZ) : (d.startZ - d.endZ);
                const angle = Math.atan2(dx, dz);
                this.el.object3D.rotation.y = angle;
            }
        });

        // =====================================================
        // GIRAFFE RUNNER COMPONENT - Makes giraffe run with bouncy animation
        // =====================================================
        AFRAME.registerComponent('giraffe-runner', {
            schema: {
                startX: { type: 'number', default: -20 },
                startZ: { type: 'number', default: -6 },
                endX: { type: 'number', default: 20 },
                endZ: { type: 'number', default: -10 },
                duration: { type: 'number', default: 25000 },
                bounceHeight: { type: 'number', default: 0.3 },
                bounceSpeed: { type: 'number', default: 8 }
            },

            init: function() {
                this.progress = 0;
                this.startTime = 0;
                this.running = true;
            },

            tick: function(time, delta) {
                if (!delta || !this.running) return;

                const d = this.data;

                // Update progress
                this.progress += delta / d.duration;

                if (this.progress >= 1) {
                    // Reset after reaching end
                    this.progress = 0;
                    this.running = false;
                    // Restart after 60 seconds
                    setTimeout(() => {
                        this.progress = 0;
                        this.running = true;
                    }, 60000);
                    return;
                }

                // Calculate position with galloping bounce
                const x = d.startX + (d.endX - d.startX) * this.progress;
                const z = d.startZ + (d.endZ - d.startZ) * this.progress;

                // Galloping motion: bounce up and down
                const bounce = Math.abs(Math.sin(time * 0.001 * d.bounceSpeed)) * d.bounceHeight;
                const y = bounce;

                this.el.object3D.position.set(x, y, z);

                // Face movement direction (+PI to flip model to face forward)
                const dx = d.endX - d.startX;
                const dz = d.endZ - d.startZ;
                const angle = Math.atan2(dx, dz) + Math.PI;
                this.el.object3D.rotation.y = angle;
            }
        });

        // =====================================================
        // FLY ORBIT COMPONENT - Makes flies circle around player
        // =====================================================
        AFRAME.registerComponent('fly-orbit', {
            schema: {
                radius: { type: 'number', default: 0.7 },
                height: { type: 'number', default: 1.4 },
                speed: { type: 'number', default: 2500 },
                direction: { type: 'number', default: 1 }
            },

            init: function() {
                this.angle = Math.random() * Math.PI * 2;
                this.wobbleOffset = Math.random() * Math.PI * 2;
            },

            tick: function(time, delta) {
                if (!delta) return;

                // Update angle based on speed
                const rotSpeed = (Math.PI * 2) / this.data.speed * delta * this.data.direction;
                this.angle += rotSpeed;

                // Calculate position with wobble
                const wobble = Math.sin(time * 0.005 + this.wobbleOffset) * 0.15;
                const x = Math.cos(this.angle) * this.data.radius;
                const z = Math.sin(this.angle) * this.data.radius;
                const y = this.data.height + wobble;

                this.el.object3D.position.set(x, y, z);
            }
        });

        // =====================================================
        // WAVY TERRAIN COMPONENT
        // =====================================================
        AFRAME.registerComponent('wavy-terrain', {
            init: function() {
                const size = 100;
                const segments = 50;
                const geometry = new THREE.PlaneGeometry(size, size, segments, segments);

                // Create wavy dunes
                const vertices = geometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const y = vertices[i + 1];
                    // Gentle rolling dunes
                    vertices[i + 2] = Math.sin(x * 0.1) * 1.5 + Math.cos(y * 0.08) * 1.2 + Math.sin((x + y) * 0.05) * 0.8;
                }
                geometry.computeVertexNormals();

                // Load texture
                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load('assets/Ground096B_1K-JPG/Ground096B_1K-JPG_Color.jpg');
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(40, 40);

                const material = new THREE.MeshStandardMaterial({
                    map: texture,
                    color: 0xd2b48c,
                    roughness: 1
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.y = -0.5;
                mesh.receiveShadow = true;

                this.el.setObject3D('mesh', mesh);
                console.log('üèúÔ∏è Wavy terrain created');
            }
        });

        // =====================================================
        // GLOBAL HAND TRACKING STATE
        // =====================================================
        const HandTracker = {
            leftHand: { position: new THREE.Vector3(), active: false, velocity: new THREE.Vector3() },
            rightHand: { position: new THREE.Vector3(), active: false, velocity: new THREE.Vector3() },
            lastLeftPos: new THREE.Vector3(),
            lastRightPos: new THREE.Vector3(),
            xrSession: null,
            xrRefSpace: null,

            init: function(scene) {
                console.log('üñêÔ∏è HandTracker initializing...');

                scene.addEventListener('enter-vr', () => {
                    console.log('ü•Ω Entered VR, setting up hand tracking...');
                    this.setupXRHandTracking(scene);
                });

                scene.addEventListener('exit-vr', () => {
                    console.log('üëã Exited VR');
                    this.leftHand.active = false;
                    this.rightHand.active = false;
                });
            },

            setupXRHandTracking: function(scene) {
                const renderer = scene.renderer;
                const xrManager = renderer.xr;

                if (!xrManager) {
                    console.warn('‚ö†Ô∏è No XR manager available');
                    return;
                }

                this.xrSession = xrManager.getSession();

                if (this.xrSession) {
                    console.log('‚úÖ XR Session found, checking for hand input...');

                    // Get reference space
                    xrManager.getReferenceSpace().then(refSpace => {
                        this.xrRefSpace = refSpace;
                        console.log('‚úÖ XR Reference space obtained');
                    });
                }
            },

            update: function(frame, refSpace) {
                if (!frame || !refSpace) return;

                const session = frame.session;
                if (!session) return;

                // Check for hand input sources
                for (const inputSource of session.inputSources) {
                    if (inputSource.hand) {
                        const hand = inputSource.hand;
                        const handedness = inputSource.handedness;

                        // Get wrist joint for hand position
                        const wristJoint = hand.get('wrist');
                        if (wristJoint) {
                            const pose = frame.getJointPose(wristJoint, refSpace);
                            if (pose) {
                                const pos = pose.transform.position;
                                const handData = handedness === 'left' ? this.leftHand : this.rightHand;
                                const lastPos = handedness === 'left' ? this.lastLeftPos : this.lastRightPos;

                                // Calculate velocity (for slap detection)
                                handData.velocity.subVectors(
                                    new THREE.Vector3(pos.x, pos.y, pos.z),
                                    lastPos
                                );

                                // Update position
                                lastPos.copy(handData.position);
                                handData.position.set(pos.x, pos.y, pos.z);
                                handData.active = true;
                            }
                        }
                    }
                }
            },

            // Fallback: Use A-Frame hand entity positions
            updateFromEntities: function(leftHandEl, rightHandEl) {
                if (leftHandEl && leftHandEl.object3D) {
                    const pos = new THREE.Vector3();
                    leftHandEl.object3D.getWorldPosition(pos);

                    // Only update if not at origin
                    if (pos.lengthSq() > 0.1) {
                        this.leftHand.velocity.subVectors(pos, this.leftHand.position);
                        this.leftHand.position.copy(pos);
                        this.leftHand.active = true;
                    }
                }

                if (rightHandEl && rightHandEl.object3D) {
                    const pos = new THREE.Vector3();
                    rightHandEl.object3D.getWorldPosition(pos);

                    if (pos.lengthSq() > 0.1) {
                        this.rightHand.velocity.subVectors(pos, this.rightHand.position);
                        this.rightHand.position.copy(pos);
                        this.rightHand.active = true;
                    }
                }
            },

            getSwipeSpeed: function(hand) {
                const data = hand === 'left' ? this.leftHand : this.rightHand;
                return data.velocity.length() * 60; // Convert to m/s (assuming 60fps)
            },

            isHandActive: function(hand) {
                return hand === 'left' ? this.leftHand.active : this.rightHand.active;
            },

            getPosition: function(hand) {
                return hand === 'left' ? this.leftHand.position : this.rightHand.position;
            }
        };

        // =====================================================
        // AUDIO ENGINE
        // =====================================================
        const AudioEngine = {
            context: null,
            windAudio: null,
            insectsAudio: null,
            squishyAudio: null,

            init: function() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                console.log('üîä Audio engine ready');
            },

            resume: function() {
                if (this.context && this.context.state === 'suspended') {
                    this.context.resume();
                }
            },

            playTone: function(type, freq, volume, duration) {
                this.resume();
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(volume, this.context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.context.destination);
                osc.start();
                osc.stop(this.context.currentTime + duration);
            },

            playSuccess: function() {
                [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                    setTimeout(() => this.playTone('sine', freq, 0.3, 0.25), i * 150);
                });
            },

            playVictory: function() {
                [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51].forEach((freq, i) => {
                    setTimeout(() => this.playTone('sine', freq, 0.3, 0.25), i * 180);
                });
            },

            playSplat: function() { this.playTone('sine', 80, 0.4, 0.1); },
            playBuzz: function() { this.playTone('sawtooth', 220 + Math.random() * 80, 0.15, 0.2); },
            playPoof: function() { this.playTone('triangle', 100, 0.2, 0.3); },
            playBlock: function() { this.playTone('square', 200, 0.3, 0.15); },
            playHeartbeat: function() { this.playTone('sine', 60, 0.4, 0.2); },

            startWind: function() {
                this.windAudio = document.getElementById('wind-loop');
                if (this.windAudio) {
                    this.windAudio.volume = 0.3;
                    this.windAudio.loop = true;
                    this.windAudio.play().catch(e => console.log('Wind play failed:', e));
                }
            },

            stopWind: function() {
                if (this.windAudio) { this.windAudio.pause(); this.windAudio.currentTime = 0; }
            },

            startInsects: function() {
                this.insectsAudio = document.getElementById('insects-loop');
                if (this.insectsAudio) {
                    this.insectsAudio.volume = 0.4;
                    this.insectsAudio.loop = true;
                    this.insectsAudio.play().catch(e => console.log('Insects play failed:', e));
                }
            },

            stopInsects: function() {
                if (this.insectsAudio) { this.insectsAudio.pause(); this.insectsAudio.currentTime = 0; }
            },

            playFart: function() {
                const fart = document.getElementById('fart-sound');
                if (fart) { fart.currentTime = 0; fart.volume = 0.6; fart.play().catch(e => {}); }
            },

            startSquishy: function() {
                this.squishyAudio = document.getElementById('squishy-loop');
                if (this.squishyAudio) {
                    this.squishyAudio.volume = 0.5;
                    this.squishyAudio.loop = true;
                    this.squishyAudio.play().catch(e => {});
                }
            },

            stopSquishy: function() {
                if (this.squishyAudio) { this.squishyAudio.pause(); this.squishyAudio.currentTime = 0; }
            }
        };

        AudioEngine.init();

        // =====================================================
        // GAME STATES
        // =====================================================
        const STATES = {
            INTRO: 'intro',
            LEVEL_1: 'level_1',  // Find Namibia (gaze cursor)
            LEVEL_2: 'level_2',  // Swat flies (hand collision)
            LEVEL_3: 'level_3',  // Block spears (shield/hand)
            LEVEL_4: 'level_4',  // Touch rhino heart (hand collision)
            VICTORY: 'victory'
        };

        // =====================================================
        // ROBUST GAME MANAGER COMPONENT
        // =====================================================
        AFRAME.registerComponent('robust-game-manager', {
            init: function() {
                console.log('üéÆ ROBUST GAME MANAGER INIT');

                this.state = null;
                this.objects = [];
                this.spears = [];
                this.score = 0;
                this.target = 0;

                // Cache elements
                this.camera = document.getElementById('camera');
                this.shield = document.getElementById('shield');
                this.leftIndicator = document.getElementById('left-hand-indicator');
                this.rightIndicator = document.getElementById('right-hand-indicator');

                // Initialize hand tracker
                HandTracker.init(this.el.sceneEl);

                // Debug update interval
                this.debugInterval = setInterval(() => this.updateDebug(), 200);

                // Expose for skip button
                window.gameManager = this;

                // Start game when scene is loaded
                this.el.sceneEl.addEventListener('loaded', () => {
                    console.log('‚úÖ Scene loaded');
                    setTimeout(() => this.startIntro(), 1500);
                });

                // Audio activation on VR enter
                this.el.sceneEl.addEventListener('enter-vr', () => {
                    AudioEngine.resume();
                    AudioEngine.startWind();
                });
            },

            tick: function(time, delta) {
                const dt = delta / 1000;

                // Update hand tracking from A-Frame entities (fallback method)
                // In VR, A-Frame creates hand entities automatically
                const leftHand = document.querySelector('[hand-tracking-controls="hand: left"]');
                const rightHand = document.querySelector('[hand-tracking-controls="hand: right"]');
                HandTracker.updateFromEntities(leftHand, rightHand);

                // Update hand indicators
                this.updateHandIndicators();

                // Level-specific tick logic
                switch (this.state) {
                    case STATES.LEVEL_2:
                        this.tickLevel2(dt);
                        break;
                    case STATES.LEVEL_3:
                        this.tickLevel3(dt);
                        break;
                    case STATES.LEVEL_4:
                        this.tickLevel4(dt);
                        break;
                }
            },

            updateHandIndicators: function() {
                // Show hand position indicators when tracking is active
                if (HandTracker.leftHand.active && this.leftIndicator) {
                    this.leftIndicator.setAttribute('visible', 'true');
                    this.leftIndicator.object3D.position.copy(HandTracker.leftHand.position);
                }
                if (HandTracker.rightHand.active && this.rightIndicator) {
                    this.rightIndicator.setAttribute('visible', 'true');
                    this.rightIndicator.object3D.position.copy(HandTracker.rightHand.position);
                }
            },

            updateDebug: function() {
                const handsEl = document.getElementById('debug-hands');
                const levelEl = document.getElementById('debug-level');

                if (handsEl) {
                    const l = HandTracker.leftHand;
                    const r = HandTracker.rightHand;
                    handsEl.textContent = `L: ${l.active ? l.position.toArray().map(v => v.toFixed(2)).join(',') : 'inactive'} | R: ${r.active ? r.position.toArray().map(v => v.toFixed(2)).join(',') : 'inactive'}`;
                }

                if (levelEl) {
                    levelEl.textContent = `Level: ${this.state || 'none'} | Score: ${this.score}/${this.target}`;
                }
            },

            updateHUD: function(title, objective, progress) {
                document.getElementById('level-title').textContent = title;
                document.getElementById('objective').textContent = objective;
                document.getElementById('progress').textContent = progress;
            },

            clearObjects: function() {
                this.objects.forEach(obj => { if (obj.parentNode) obj.parentNode.removeChild(obj); });
                this.objects = [];
                this.spears = [];
            },

            showBriefing: function(title, message, instructions, callback) {
                // Execute callback immediately
                if (callback) callback();

                // Create 3D briefing panel
                const panel = document.createElement('a-entity');
                panel.setAttribute('id', 'briefing');
                panel.setAttribute('position', '0 1.6 -2');
                panel.setAttribute('look-at', '[camera]');

                // Background
                const bg = document.createElement('a-plane');
                bg.setAttribute('width', '3');
                bg.setAttribute('height', '2.2');
                bg.setAttribute('color', '#000000');
                bg.setAttribute('opacity', '0.9');
                panel.appendChild(bg);

                // Title
                const titleEl = document.createElement('a-text');
                titleEl.setAttribute('value', title);
                titleEl.setAttribute('align', 'center');
                titleEl.setAttribute('color', '#00FF00');
                titleEl.setAttribute('width', '2.8');
                titleEl.setAttribute('position', '0 0.7 0.01');
                panel.appendChild(titleEl);

                // Message
                const msgEl = document.createElement('a-text');
                msgEl.setAttribute('value', message);
                msgEl.setAttribute('align', 'center');
                msgEl.setAttribute('color', '#FFFFFF');
                msgEl.setAttribute('width', '2.5');
                msgEl.setAttribute('position', '0 0.2 0.01');
                msgEl.setAttribute('wrap-count', '35');
                panel.appendChild(msgEl);

                // Instructions
                const instrEl = document.createElement('a-text');
                instrEl.setAttribute('value', instructions);
                instrEl.setAttribute('align', 'center');
                instrEl.setAttribute('color', '#FFD700');
                instrEl.setAttribute('width', '2.5');
                instrEl.setAttribute('position', '0 -0.4 0.01');
                instrEl.setAttribute('wrap-count', '40');
                panel.appendChild(instrEl);

                // Continue button
                const btn = document.createElement('a-plane');
                btn.setAttribute('width', '1.5');
                btn.setAttribute('height', '0.4');
                btn.setAttribute('color', '#00FF00');
                btn.setAttribute('position', '0 -0.85 0.01');
                btn.classList.add('clickable');

                const btnText = document.createElement('a-text');
                btnText.setAttribute('value', 'DOORGAAN');
                btnText.setAttribute('align', 'center');
                btnText.setAttribute('color', '#000000');
                btnText.setAttribute('width', '3');
                btnText.setAttribute('position', '0 0 0.01');
                btn.appendChild(btnText);

                btn.addEventListener('click', () => {
                    if (panel.parentNode) panel.parentNode.removeChild(panel);
                });

                panel.appendChild(btn);
                this.el.sceneEl.appendChild(panel);
            },

            skipLevel: function() {
                console.log('‚è≠Ô∏è Skipping:', this.state);
                switch (this.state) {
                    case STATES.INTRO: this.startLevel1(); break;
                    case STATES.LEVEL_1: this.completeLevel1(); break;
                    case STATES.LEVEL_2: this.completeLevel2(); break;
                    case STATES.LEVEL_3: this.completeLevel3(); break;
                    case STATES.LEVEL_4: this.completeLevel4(); break;
                    case STATES.VICTORY: location.reload(); break;
                }
            },

            createExplosion: function(pos, color, count) {
                for (let i = 0; i < count; i++) {
                    const p = document.createElement('a-sphere');
                    p.setAttribute('radius', 0.05 + Math.random() * 0.05);
                    p.setAttribute('color', color);
                    p.setAttribute('position', pos);
                    p.setAttribute('animation__pos', {
                        property: 'position',
                        to: `${pos.x + (Math.random()-0.5)*3} ${pos.y + Math.random()*2} ${pos.z + (Math.random()-0.5)*3}`,
                        dur: 1000,
                        easing: 'easeOutQuad'
                    });
                    p.setAttribute('animation__scale', {
                        property: 'scale',
                        to: '0 0 0',
                        dur: 1000,
                        easing: 'easeInQuad'
                    });
                    this.el.sceneEl.appendChild(p);
                    setTimeout(() => { if (p.parentNode) p.parentNode.removeChild(p); }, 1000);
                }
            },

            // =====================================================
            // INTRO
            // =====================================================
            startIntro: function() {
                console.log('üé¨ INTRO');
                this.state = STATES.INTRO;
                this.updateHUD('üåç VIBEKE\'S GROTE EXPEDITIE', 'Klaar voor het avontuur?', '');

                // Spawn environment
                this.spawnTrees();
                this.spawnAmbientAnimals();

                setTimeout(() => this.startLevel1(), 3000);
            },

            spawnAmbientAnimals: function() {
                const types = ['deer', 'stag', 'bull', 'horse', 'fox'];

                // Spawn grazing animals that wander around
                for (let i = 0; i < 6; i++) {
                    const type = types[Math.floor(Math.random() * types.length)];
                    if (!document.getElementById(`${type}-asset`)) continue;

                    const animal = document.createElement('a-entity');
                    animal.setAttribute('gltf-model', `#${type}-asset`);

                    // Position around player but not too close
                    const angle = (Math.PI * 2 / 6) * i + Math.random() * 0.5;
                    const dist = 12 + Math.random() * 15;
                    const x = Math.cos(angle) * dist;
                    const z = Math.sin(angle) * dist - 5;

                    animal.setAttribute('position', `${x} 0 ${z}`);
                    animal.setAttribute('scale', '0.3 0.3 0.3');

                    // Pick a random walk direction
                    const walkAngle = Math.random() * Math.PI * 2;
                    const walkDist = 5 + Math.random() * 8;
                    const targetX = x + Math.cos(walkAngle) * walkDist;
                    const targetZ = z + Math.sin(walkAngle) * walkDist;

                    // Use animal-walker component for proper orientation
                    animal.setAttribute('animal-walker', {
                        startX: x, startZ: z,
                        endX: targetX, endZ: targetZ,
                        duration: 20000 + Math.random() * 15000
                    });

                    // Walking animation (slower)
                    animal.setAttribute('animation-mixer', 'clip: *; loop: repeat; timeScale: 0.6');

                    this.el.sceneEl.appendChild(animal);
                }

                // Spawn running giraffe that passes by the player
                this.spawnRunningGiraffe();
            },

            spawnRunningGiraffe: function() {
                if (!document.getElementById('giraffe-asset')) return;

                const giraffe = document.createElement('a-entity');
                giraffe.setAttribute('gltf-model', '#giraffe-asset');
                giraffe.setAttribute('scale', '1.2 1.2 1.2');

                // Use giraffe-runner component for galloping motion
                giraffe.setAttribute('giraffe-runner', {
                    startX: -18,
                    startZ: -5,
                    endX: 18,
                    endZ: -8,
                    duration: 20000,
                    bounceHeight: 0.25,
                    bounceSpeed: 6
                });

                // Running animation synced with bounce
                giraffe.setAttribute('animation-mixer', 'clip: *; loop: repeat; timeScale: 1.2');

                this.el.sceneEl.appendChild(giraffe);
            },

            spawnTrees: function() {
                // Spawn Acacia trees around the scene
                const treePositions = [
                    { x: -15, z: -20 },
                    { x: 20, z: -25 },
                    { x: -25, z: 5 },
                    { x: 30, z: -10 },
                    { x: -8, z: -30 }
                ];

                treePositions.forEach((pos, i) => {
                    const tree = document.createElement('a-entity');

                    if (document.getElementById('tree-asset')) {
                        tree.setAttribute('gltf-model', '#tree-asset');
                        tree.setAttribute('scale', '2 2 2');
                    } else {
                        // Fallback: simple cone tree
                        const trunk = document.createElement('a-cylinder');
                        trunk.setAttribute('radius', '0.3');
                        trunk.setAttribute('height', '3');
                        trunk.setAttribute('color', '#8B4513');
                        trunk.setAttribute('position', '0 1.5 0');
                        tree.appendChild(trunk);

                        const leaves = document.createElement('a-cone');
                        leaves.setAttribute('radius-bottom', '2');
                        leaves.setAttribute('height', '1');
                        leaves.setAttribute('color', '#228B22');
                        leaves.setAttribute('position', '0 3.5 0');
                        tree.appendChild(leaves);
                    }

                    tree.setAttribute('position', `${pos.x} 0 ${pos.z}`);
                    tree.setAttribute('rotation', `0 ${Math.random() * 360} 0`);

                    this.el.sceneEl.appendChild(tree);
                });

                console.log('üå≥ Trees spawned');
            },

            // =====================================================
            // LEVEL 1: FIND NAMIBIA (Gaze Cursor)
            // =====================================================
            startLevel1: function() {
                console.log('üåç LEVEL 1: Find Namibia');
                this.state = STATES.LEVEL_1;
                this.clearObjects();
                this.updateHUD('üåç NIVEAU 1: DE BESTEMMING', 'Zoek Namibi√´!', '');

                this.showBriefing(
                    'NIVEAU 1: DE BESTEMMING',
                    'Lieve Vibeke,\n\nWe gaan op reis!\nMaar waarheen?\n\nZoek de juiste bestemming...',
                    'KIJK 1 seconde naar NAMIBI√ã',
                    () => this.spawnGlobes()
                );
            },

            spawnGlobes: function() {
                const destinations = [
                    { name: 'Xian', target: false },
                    { name: 'Texel', target: false },
                    { name: 'Jeruzalem', target: false },
                    { name: 'Denemarken', target: false },
                    { name: 'Hongarije', target: false },
                    { name: 'NAMIBI√ã', target: true }
                ];

                destinations.forEach((dest, i) => {
                    setTimeout(() => {
                        if (this.state !== STATES.LEVEL_1) return;

                        const angle = (Math.PI * 2 / destinations.length) * i + Math.PI;
                        const radius = 5;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;

                        // Globe container
                        const globe = document.createElement('a-entity');
                        globe.setAttribute('position', `${x} 1.6 ${z}`);
                        globe.classList.add('clickable');
                        globe.dataset.target = dest.target;
                        globe.dataset.name = dest.name;

                        // Visible sphere
                        const sphere = document.createElement('a-sphere');
                        sphere.setAttribute('radius', '0.5');
                        sphere.setAttribute('color', dest.target ? '#FFD700' : '#4169E1');
                        sphere.setAttribute('metalness', '0.5');
                        globe.appendChild(sphere);

                        // Hitbox
                        const hitbox = document.createElement('a-sphere');
                        hitbox.setAttribute('radius', '1.2');
                        hitbox.setAttribute('opacity', '0');
                        hitbox.setAttribute('transparent', 'true');
                        hitbox.classList.add('clickable');
                        globe.appendChild(hitbox);

                        // Rotation animation
                        globe.setAttribute('animation', {
                            property: 'rotation',
                            to: '0 360 0',
                            dur: 10000,
                            loop: true,
                            easing: 'linear'
                        });

                        // Click handler
                        globe.addEventListener('click', () => this.handleGlobeClick(globe, dest));
                        hitbox.addEventListener('click', () => this.handleGlobeClick(globe, dest));

                        this.el.sceneEl.appendChild(globe);
                        this.objects.push(globe);

                        // Label (separate, doesn't rotate)
                        const label = document.createElement('a-entity');
                        label.setAttribute('position', `${x} 2.5 ${z}`);
                        label.setAttribute('look-at', '[camera]');

                        const text = document.createElement('a-text');
                        text.setAttribute('value', dest.name);
                        text.setAttribute('align', 'center');
                        text.setAttribute('color', dest.target ? '#FF6347' : '#FFFFFF');
                        text.setAttribute('width', '4');
                        label.appendChild(text);

                        this.el.sceneEl.appendChild(label);
                        this.objects.push(label);

                    }, i * 400);
                });
            },

            handleGlobeClick: function(globe, dest) {
                console.log('üåç Clicked:', dest.name, 'target:', dest.target);

                if (dest.target) {
                    AudioEngine.playSuccess();
                    this.updateHUD('‚úÖ GEVONDEN!', `${dest.name}!`, '');
                    this.createExplosion(globe.object3D.position, '#FFD700', 40);
                    setTimeout(() => this.completeLevel1(), 1500);
                } else {
                    AudioEngine.playPoof();
                    this.createExplosion(globe.object3D.position, '#888888', 15);
                    if (globe.parentNode) globe.parentNode.removeChild(globe);
                    this.objects = this.objects.filter(o => o !== globe);
                }
            },

            completeLevel1: function() {
                console.log('‚úÖ Level 1 complete');
                this.clearObjects();
                AudioEngine.playSuccess();
                this.updateHUD('‚úÖ NIVEAU 1 VOLTOOID!', 'We gaan naar NAMIBI√ã!', '');
                setTimeout(() => this.startLevel2(), 2000);
            },

            // =====================================================
            // LEVEL 2: SWAT FLIES (Hand Collision)
            // =====================================================
            startLevel2: function() {
                console.log('ü™∞ LEVEL 2: Swat Flies');
                this.state = STATES.LEVEL_2;
                this.clearObjects();
                this.score = 0;
                this.target = 10;
                AudioEngine.startInsects();
                this.updateHUD('ü™∞ NIVEAU 2: DE VOORBEREIDING', 'Mep de vliegen!', `${this.score}/${this.target}`);

                this.showBriefing(
                    'NIVEAU 2: DE VOORBEREIDING',
                    'Pas op!\nIn de rimboe zoemen veel beestjes!\n\nMep 10 vliegen weg!',
                    'SLA met je HANDEN naar de vliegen!',
                    () => this.spawnFlies()
                );
            },

            spawnFlies: function() {
                const total = 18;
                for (let i = 0; i < total; i++) {
                    setTimeout(() => {
                        if (this.state !== STATES.LEVEL_2) return;
                        this.spawnFly();
                    }, i * 600);
                }
            },

            spawnFly: function() {
                const fly = document.createElement('a-entity');

                // Use model if available
                if (document.getElementById('fly-model')) {
                    fly.setAttribute('gltf-model', '#fly-model');
                    fly.setAttribute('scale', '0.08 0.08 0.08');
                } else {
                    // Fallback sphere
                    const sphere = document.createElement('a-sphere');
                    sphere.setAttribute('radius', '0.1');
                    sphere.setAttribute('color', '#111111');
                    fly.appendChild(sphere);
                }

                fly.classList.add('fly');

                // Start position - random around player
                const startAngle = Math.random() * Math.PI * 2;
                const startDist = 0.5 + Math.random() * 0.5;
                const startX = Math.sin(startAngle) * startDist;
                const startY = 1.0 + Math.random() * 0.8; // Head height
                const startZ = -Math.cos(startAngle) * startDist;

                fly.setAttribute('position', `${startX} ${startY} ${startZ}`);
                fly.dataset.splatted = 'false';

                // Fly in circles around player - each fly gets unique orbit
                const orbitRadius = 0.6 + Math.random() * 0.4;
                const orbitSpeed = 2000 + Math.random() * 1500; // 2-3.5 seconds per orbit
                const orbitY = 1.0 + Math.random() * 0.6;
                const orbitDirection = Math.random() > 0.5 ? 1 : -1; // CW or CCW

                // Create orbit animation using custom component
                fly.setAttribute('fly-orbit', {
                    radius: orbitRadius,
                    height: orbitY,
                    speed: orbitSpeed,
                    direction: orbitDirection
                });

                AudioEngine.playBuzz();

                this.el.sceneEl.appendChild(fly);
                this.objects.push(fly);
            },

            tickLevel2: function(dt) {
                // Only check hand collisions if at least one hand is ACTUALLY tracking
                if (!HandTracker.leftHand.active && !HandTracker.rightHand.active) {
                    return; // No hands tracking, skip collision checks
                }

                const flies = this.objects.filter(o => o.classList && o.classList.contains('fly') && o.dataset.splatted === 'false');

                // Check hand collisions
                flies.forEach(fly => {
                    const flyPos = new THREE.Vector3();
                    fly.object3D.getWorldPosition(flyPos);

                    let hit = false;
                    const hitRadius = 0.30; // 30cm - slightly smaller

                    // Check left hand - require meaningful speed
                    if (HandTracker.leftHand.active) {
                        const dist = HandTracker.leftHand.position.distanceTo(flyPos);
                        const speed = HandTracker.getSwipeSpeed('left');
                        if (dist < hitRadius && speed > 0.5) { // Need some movement
                            hit = true;
                            console.log(`ü™∞ HIT! L dist=${dist.toFixed(2)} speed=${speed.toFixed(2)}`);
                        }
                    }

                    // Check right hand
                    if (HandTracker.rightHand.active) {
                        const dist = HandTracker.rightHand.position.distanceTo(flyPos);
                        const speed = HandTracker.getSwipeSpeed('right');
                        if (dist < hitRadius && speed > 0.5) {
                            hit = true;
                            console.log(`ü™∞ HIT! R dist=${dist.toFixed(2)} speed=${speed.toFixed(2)}`);
                        }
                    }

                    if (hit) {
                        this.splatFly(fly);
                    }
                });
            },

            splatFly: function(fly) {
                if (fly.dataset.splatted === 'true') return;
                fly.dataset.splatted = 'true';

                this.score++;
                AudioEngine.playSplat();
                this.updateHUD('ü™∞ NIVEAU 2', 'Mep die vliegen!', `${this.score}/${this.target}`);

                this.createExplosion(fly.object3D.position, '#111111', 15);

                if (fly.parentNode) fly.parentNode.removeChild(fly);
                this.objects = this.objects.filter(o => o !== fly);

                if (this.score >= this.target) {
                    setTimeout(() => this.completeLevel2(), 500);
                }
            },

            completeLevel2: function() {
                console.log('‚úÖ Level 2 complete');
                this.clearObjects();
                AudioEngine.stopInsects();
                AudioEngine.playSuccess();
                this.updateHUD('‚úÖ NIVEAU 2 VOLTOOID!', 'Perfect!', '');
                setTimeout(() => this.startLevel3(), 2000);
            },

            // =====================================================
            // LEVEL 3: BLOCK SPEARS (Shield)
            // =====================================================
            startLevel3: function() {
                console.log('üõ°Ô∏è LEVEL 3: Block Spears');
                this.state = STATES.LEVEL_3;
                this.clearObjects();
                this.score = 0;
                this.target = 15;
                this.updateHUD('üõ°Ô∏è NIVEAU 3: DE BESCHERMER', 'Blokkeer speren!', `${this.score}/${this.target}`);

                // Show shield
                if (this.shield) this.shield.setAttribute('visible', 'true');

                this.showBriefing(
                    'NIVEAU 3: DE BESCHERMER',
                    'Jij moet de familie beschermen!\n\nBlokkeer 15 speren!',
                    'Beweeg je LINKERHAND\nom het schild te positioneren!',
                    () => this.setupLevel3()
                );
            },

            setupLevel3: function() {
                // Spawn bushes with hunters
                this.hunters = [];
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 / 5) * i;
                    const dist = 10 + Math.random() * 3;
                    const x = Math.cos(angle) * dist;
                    const z = Math.sin(angle) * dist;

                    // Bush
                    const bush = document.createElement('a-sphere');
                    bush.setAttribute('radius', '1.5');
                    bush.setAttribute('position', `${x} 1 ${z}`);
                    bush.setAttribute('color', '#2d5016');
                    bush.setAttribute('material', 'roughness: 1');
                    this.el.sceneEl.appendChild(bush);
                    this.objects.push(bush);

                    // Hunter behind bush
                    const hunter = document.createElement('a-entity');
                    if (document.getElementById('hunter-asset')) {
                        hunter.setAttribute('gltf-model', '#hunter-asset');
                        hunter.setAttribute('scale', '1 1 1');
                    } else {
                        // Fallback: simple figure
                        const body = document.createElement('a-cylinder');
                        body.setAttribute('radius', '0.25');
                        body.setAttribute('height', '1.5');
                        body.setAttribute('color', '#8B4513');
                        body.setAttribute('position', '0 0.75 0');
                        hunter.appendChild(body);

                        const head = document.createElement('a-sphere');
                        head.setAttribute('radius', '0.2');
                        head.setAttribute('color', '#DEB887');
                        head.setAttribute('position', '0 1.7 0');
                        hunter.appendChild(head);
                    }

                    // Position hunter slightly behind bush, facing player
                    const hunterX = x * 1.15;
                    const hunterZ = z * 1.15;
                    hunter.setAttribute('position', `${hunterX} 0 ${hunterZ}`);

                    // Face toward player
                    const lookAngle = Math.atan2(-hunterX, -hunterZ) * (180 / Math.PI);
                    hunter.setAttribute('rotation', `0 ${lookAngle} 0`);

                    hunter.dataset.bushX = x;
                    hunter.dataset.bushZ = z;

                    this.el.sceneEl.appendChild(hunter);
                    this.objects.push(hunter);
                    this.hunters.push(hunter);
                }

                // Start spawning spears - one every 0.8 seconds (more frequent!)
                this.spearInterval = setInterval(() => {
                    if (this.state === STATES.LEVEL_3) {
                        this.launchSpear();
                    } else {
                        clearInterval(this.spearInterval);
                    }
                }, 800);
            },

            launchSpear: function() {
                const spear = document.createElement('a-entity');

                // Pick a random hunter to throw spear
                let x, z, y;
                if (this.hunters && this.hunters.length > 0) {
                    const hunter = this.hunters[Math.floor(Math.random() * this.hunters.length)];
                    x = parseFloat(hunter.dataset.bushX);
                    z = parseFloat(hunter.dataset.bushZ);
                    y = 1.8; // Thrown from shoulder height
                } else {
                    // Fallback: random position
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 10 + Math.random() * 3;
                    x = Math.cos(angle) * dist;
                    z = Math.sin(angle) * dist;
                    y = 1.5;
                }

                spear.setAttribute('position', `${x} ${y} ${z}`);
                spear.classList.add('spear');

                // Spear visual
                const shaft = document.createElement('a-cylinder');
                shaft.setAttribute('radius', '0.04');
                shaft.setAttribute('height', '2');
                shaft.setAttribute('color', '#8B4513');
                shaft.setAttribute('rotation', '0 0 90');
                spear.appendChild(shaft);

                const tip = document.createElement('a-cone');
                tip.setAttribute('radius-bottom', '0.1');
                tip.setAttribute('height', '0.3');
                tip.setAttribute('color', '#C0C0C0');
                tip.setAttribute('position', '1 0 0');
                tip.setAttribute('rotation', '0 0 -90');
                spear.appendChild(tip);

                // Calculate direction to player
                const targetPos = new THREE.Vector3(0, 1.5, 0);
                const startPos = new THREE.Vector3(x, y, z);
                const dir = new THREE.Vector3().subVectors(targetPos, startPos).normalize();

                spear.userData = {
                    velocity: dir.multiplyScalar(8), // 8 m/s
                    active: true
                };

                // Make spear look at target
                spear.object3D.lookAt(targetPos);

                this.el.sceneEl.appendChild(spear);
                this.spears.push(spear);
            },

            tickLevel3: function(dt) {
                // Update shield position based on left hand
                if (HandTracker.leftHand.active && this.shield) {
                    this.shield.object3D.position.copy(HandTracker.leftHand.position);
                } else if (this.camera && this.shield) {
                    // Fallback: shield follows camera
                    const camPos = new THREE.Vector3();
                    const camDir = new THREE.Vector3();
                    this.camera.object3D.getWorldPosition(camPos);
                    this.camera.object3D.getWorldDirection(camDir);

                    const shieldPos = camPos.clone().addScaledVector(camDir, -0.8);
                    shieldPos.y = camPos.y;
                    this.shield.object3D.position.copy(shieldPos);
                }

                const shieldPos = new THREE.Vector3();
                if (this.shield) this.shield.object3D.getWorldPosition(shieldPos);

                // Update spears
                this.spears.forEach(spear => {
                    if (!spear.userData || !spear.userData.active) return;

                    // Move spear
                    const v = spear.userData.velocity;
                    spear.object3D.position.x += v.x * dt;
                    spear.object3D.position.y += v.y * dt;
                    spear.object3D.position.z += v.z * dt;

                    const spearPos = spear.object3D.position;

                    // Check shield collision
                    const distToShield = shieldPos.distanceTo(spearPos);
                    if (distToShield < 0.8) {
                        spear.userData.active = false;
                        this.score++;
                        AudioEngine.playBlock();
                        this.updateHUD('üõ°Ô∏è NIVEAU 3', 'Geblokkeerd!', `${this.score}/${this.target}`);
                        this.createExplosion(spearPos, '#FFD700', 20);
                        if (spear.parentNode) spear.parentNode.removeChild(spear);

                        if (this.score >= this.target) {
                            setTimeout(() => this.completeLevel3(), 500);
                        }
                        return;
                    }

                    // Check if spear passed player (miss)
                    const camPos = new THREE.Vector3();
                    this.camera.object3D.getWorldPosition(camPos);
                    if (spearPos.distanceTo(camPos) < 1.5) {
                        // Auto-block for accessibility
                        spear.userData.active = false;
                        this.score++;
                        AudioEngine.playBlock();
                        this.updateHUD('üõ°Ô∏è NIVEAU 3', 'Net op tijd!', `${this.score}/${this.target}`);
                        this.createExplosion(spearPos, '#FFD700', 15);
                        if (spear.parentNode) spear.parentNode.removeChild(spear);

                        if (this.score >= this.target) {
                            setTimeout(() => this.completeLevel3(), 500);
                        }
                    }

                    // Remove if too far
                    if (spearPos.lengthSq() > 400) {
                        spear.userData.active = false;
                        if (spear.parentNode) spear.parentNode.removeChild(spear);
                    }
                });

                // Cleanup inactive spears
                this.spears = this.spears.filter(s => s.userData && s.userData.active);
            },

            completeLevel3: function() {
                console.log('‚úÖ Level 3 complete');
                clearInterval(this.spearInterval);
                if (this.shield) this.shield.setAttribute('visible', 'false');
                this.clearObjects();
                this.spears = [];
                AudioEngine.playSuccess();
                this.updateHUD('‚úÖ NIVEAU 3 VOLTOOID!', 'Je bent een held!', '');
                setTimeout(() => this.startLevel4(), 2000);
            },

            // =====================================================
            // LEVEL 4: RHINO HEART (Hand Touch)
            // =====================================================
            startLevel4: function() {
                console.log('ü¶è LEVEL 4: Rhino Heart');
                this.state = STATES.LEVEL_4;
                this.clearObjects();
                this.rhinoTouched = false;
                this.heartTouched = false;
                this.updateHUD('ü¶è NIVEAU 4: DE ONTMOETING', 'De Big Five!', '');

                this.showBriefing(
                    'NIVEAU 4: DE ONTMOETING',
                    'Kijk! De Big Five!\n\nDeze neushoorn heeft\niets bijzonders voor je...',
                    'Steek je HAND in de neushoorn\nom het hart te vinden!',
                    () => this.spawnRhino()
                );
            },

            spawnRhino: function() {
                const container = document.createElement('a-entity');
                container.setAttribute('id', 'rhino-boss');
                container.setAttribute('position', '0 0.5 -3');

                // Rhino body (clickable for desktop)
                let rhinoBody;
                if (document.getElementById('rhino-asset')) {
                    rhinoBody = document.createElement('a-entity');
                    rhinoBody.setAttribute('gltf-model', '#rhino-asset');
                    rhinoBody.setAttribute('scale', '2.5 2.5 2.5');
                    rhinoBody.setAttribute('rotation', '0 200 0');
                    rhinoBody.classList.add('rhino-body', 'clickable');

                    rhinoBody.setAttribute('animation__breath', {
                        property: 'scale',
                        from: '2.5 2.5 2.5',
                        to: '2.55 2.55 2.55',
                        dur: 3000,
                        loop: true,
                        dir: 'alternate'
                    });

                    container.appendChild(rhinoBody);
                } else {
                    // Fallback box
                    rhinoBody = document.createElement('a-box');
                    rhinoBody.setAttribute('width', '2.5');
                    rhinoBody.setAttribute('height', '1.5');
                    rhinoBody.setAttribute('depth', '1.2');
                    rhinoBody.setAttribute('color', '#696969');
                    rhinoBody.setAttribute('position', '0 0.75 0');
                    rhinoBody.classList.add('rhino-body', 'clickable');
                    container.appendChild(rhinoBody);
                }

                // Click handler for desktop/gaze cursor
                rhinoBody.addEventListener('click', () => {
                    if (!this.rhinoTouched) {
                        this.activateRhinoXRay();
                    }
                });

                // Heart (hidden initially, clickable)
                const heart = document.createElement('a-entity');
                heart.setAttribute('id', 'rhino-heart');
                heart.setAttribute('position', '0 0.5 0');
                heart.setAttribute('visible', 'false');
                heart.classList.add('clickable');

                if (document.getElementById('heart-model')) {
                    heart.setAttribute('gltf-model', '#heart-model');
                    heart.setAttribute('scale', '0.08 0.08 0.08'); // Bigger for visibility
                } else {
                    const sphere = document.createElement('a-sphere');
                    sphere.setAttribute('radius', '0.2'); // Bigger
                    sphere.setAttribute('color', '#DC143C');
                    sphere.setAttribute('material', 'emissive: #FF0000; emissiveIntensity: 1');
                    heart.appendChild(sphere);
                }

                heart.setAttribute('animation__pulse', {
                    property: 'scale',
                    from: '0.08 0.08 0.08',
                    to: '0.1 0.1 0.1',
                    dur: 600,
                    loop: true,
                    dir: 'alternate'
                });

                // Click handler for heart (desktop/gaze)
                heart.addEventListener('click', () => {
                    if (this.rhinoTouched && !this.heartTouched) {
                        this.touchHeart();
                    }
                });

                container.appendChild(heart);

                // Label
                const label = document.createElement('a-text');
                label.setAttribute('id', 'rhino-label');
                label.setAttribute('value', 'Steek je hand erin...');
                label.setAttribute('align', 'center');
                label.setAttribute('color', '#FFD700');
                label.setAttribute('width', '3');
                label.setAttribute('position', '0 2.5 0');
                label.setAttribute('look-at', '[camera]');
                container.appendChild(label);

                this.el.sceneEl.appendChild(container);
                this.objects.push(container);
            },

            // Activate rhino X-ray mode (called by click or hand touch)
            activateRhinoXRay: function() {
                if (this.rhinoTouched) return;
                this.rhinoTouched = true;
                console.log('ü¶è Rhino X-ray activated!');

                AudioEngine.playFart();
                AudioEngine.startSquishy();

                const rhino = document.getElementById('rhino-boss');
                if (!rhino) return;

                // Make rhino semi-transparent - need to traverse GLTF mesh
                const rhinoBody = rhino.querySelector('.rhino-body');
                if (rhinoBody && rhinoBody.object3D) {
                    rhinoBody.object3D.traverse((child) => {
                        if (child.isMesh && child.material) {
                            // Handle array of materials or single material
                            const materials = Array.isArray(child.material) ? child.material : [child.material];
                            materials.forEach(mat => {
                                mat.transparent = true;
                                mat.opacity = 0.3;
                                mat.needsUpdate = true;
                            });
                        }
                    });
                    console.log('ü¶è Rhino made transparent');
                }

                // Show heart
                const heart = document.getElementById('rhino-heart');
                if (heart) heart.setAttribute('visible', 'true');

                // Update label
                const label = document.getElementById('rhino-label');
                if (label) label.setAttribute('value', 'Raak het hart aan!');

                this.updateHUD('ü¶è NIVEAU 4', 'Klik op het hart!', '');

                // Start heartbeat
                this.heartbeatInterval = setInterval(() => {
                    if (!this.heartTouched) AudioEngine.playHeartbeat();
                }, 700);
            },

            // Touch heart (called by click or hand touch)
            touchHeart: function() {
                if (this.heartTouched) return;
                this.heartTouched = true;
                console.log('üíñ Heart touched!');

                clearInterval(this.heartbeatInterval);
                AudioEngine.stopSquishy();
                AudioEngine.playSuccess();

                const heart = document.getElementById('rhino-heart');
                if (heart) {
                    const heartPos = new THREE.Vector3();
                    heart.object3D.getWorldPosition(heartPos);
                    this.createExplosion(heartPos, '#FF0000', 50);
                }

                setTimeout(() => this.completeLevel4(), 1500);
            },

            tickLevel4: function(dt) {
                // Only check hand collisions if hands are tracking
                if (!HandTracker.leftHand.active && !HandTracker.rightHand.active) {
                    return; // Rely on click handlers for desktop
                }

                const rhino = document.getElementById('rhino-boss');
                if (!rhino) return;

                const rhinoPos = new THREE.Vector3();
                rhino.object3D.getWorldPosition(rhinoPos);

                // Check for hand entering rhino
                const touchRadius = 1.5;
                let handInRhino = false;

                if (HandTracker.leftHand.active) {
                    const dist = HandTracker.leftHand.position.distanceTo(rhinoPos);
                    if (dist < touchRadius) handInRhino = true;
                }
                if (HandTracker.rightHand.active) {
                    const dist = HandTracker.rightHand.position.distanceTo(rhinoPos);
                    if (dist < touchRadius) handInRhino = true;
                }

                if (handInRhino && !this.rhinoTouched) {
                    this.activateRhinoXRay();
                }

                // Check for heart touch (VR hand tracking)
                if (this.rhinoTouched && !this.heartTouched) {
                    const heart = document.getElementById('rhino-heart');
                    if (heart) {
                        const heartPos = new THREE.Vector3();
                        heart.object3D.getWorldPosition(heartPos);
                        const heartRadius = 0.4;

                        let touched = false;
                        if (HandTracker.leftHand.active) {
                            if (HandTracker.leftHand.position.distanceTo(heartPos) < heartRadius) touched = true;
                        }
                        if (HandTracker.rightHand.active) {
                            if (HandTracker.rightHand.position.distanceTo(heartPos) < heartRadius) touched = true;
                        }

                        if (touched) {
                            this.touchHeart();
                        }
                    }
                }
            },

            completeLevel4: function() {
                console.log('‚úÖ Level 4 complete');
                this.clearObjects();
                this.updateHUD('üíñ NIVEAU 4 VOLTOOID!', 'Het hart van Afrika!', '');
                setTimeout(() => this.startVictory(), 2000);
            },

            // =====================================================
            // VICTORY
            // =====================================================
            startVictory: function() {
                console.log('üèÜ VICTORY!');
                this.state = STATES.VICTORY;
                AudioEngine.playVictory();
                this.updateHUD('üèÜ MISSIE VOLTOOID!', 'GEFELICITEERD VIBEKE!', '');

                // Fireworks
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        const pos = new THREE.Vector3(
                            (Math.random() - 0.5) * 8,
                            2 + Math.random() * 4,
                            -3 - Math.random() * 4
                        );
                        const colors = ['#FFD700', '#FF6347', '#00FF00', '#87CEEB', '#FF69B4'];
                        this.createExplosion(pos, colors[i % colors.length], 60);
                    }, i * 600);
                }

                // Final message
                setTimeout(() => {
                    const panel = document.createElement('a-entity');
                    panel.setAttribute('position', '0 1.6 -4');
                    panel.setAttribute('look-at', '[camera]');

                    const bg = document.createElement('a-plane');
                    bg.setAttribute('width', '4');
                    bg.setAttribute('height', '2.5');
                    bg.setAttribute('color', '#000000');
                    bg.setAttribute('opacity', '0.9');
                    panel.appendChild(bg);

                    const title = document.createElement('a-text');
                    title.setAttribute('value', 'üèÜ GEFELICITEERD VIBEKE!');
                    title.setAttribute('align', 'center');
                    title.setAttribute('color', '#FFD700');
                    title.setAttribute('width', '4');
                    title.setAttribute('position', '0 0.8 0.01');
                    panel.appendChild(title);

                    const msg = document.createElement('a-text');
                    msg.setAttribute('value', 'DIT IS JE CADEAU!\n\nGraai nu met je handen\nnaar beneden in het zand\nom je schat te vinden!');
                    msg.setAttribute('align', 'center');
                    msg.setAttribute('color', '#FFFFFF');
                    msg.setAttribute('width', '3.5');
                    msg.setAttribute('position', '0 0 0.01');
                    msg.setAttribute('wrap-count', '30');
                    panel.appendChild(msg);

                    this.el.sceneEl.appendChild(panel);
                }, 5000);
            }
        });

        console.log('‚úÖ Game script loaded');
    </script>

</body>
</html>
